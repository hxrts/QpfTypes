import Qpf

/-!
# Interaction Trees

We define interaction trees, a coinductive data-structure used for giving
semantics of side-effect producing, possibly non-terminating, programs.

[1] https://arxiv.org/abs/1906.00046
[2] https://github.com/DeepSpec/InteractionTrees
-/

/-
## Hacks / Workarounds

We'd like to define interaction trees as follows:
```
codata ITree (ε : Type → Type) ρ where
  | ret (r : ρ)
  | tau (t : ITree ε ρ)
  | vis {α : Type} (e : ε α) (k : α → ITree ε ρ)
```
Unfortunately, `vis` in that definition is a dependent arrow in disguise,
and dependent arrows are currently not supported by the framework yet.

What is supported, though, are sigma types, as in the following, equivalent,
definition
```
codata ITree (ε : Type → Type) ρ where
  | ret (r : ρ)
  | tau (t : ITree ε ρ)
  | vis (e : Σ α : Type, ε α × α → ITree ε ρ)
```

Unfortunately, this, too yields an error, so for now we settle for fixing a
particular input type `α`, by making `α` a parameter of the type.
-/

codata ITree (α : Type) ε ρ where
  | ret (r : ρ)
  | tau (t : ITree α ε ρ)
  | vis : ε → (α → ITree α ε ρ) → ITree α ε ρ


namespace ITree

/-- the corecursion principle on itrees is the low-level way of defining a
cotree, as being generated by some transition function `f`
from initial state `b` -/
def corec {β α ε ρ : Type} (f : β → ITree.Base α ε ρ β) (b : β) : ITree α ε ρ :=
  MvQPF.Cofix.corec (F := TypeFun.ofCurried (ITree.Base α)) f b

@[cases_eliminator, elab_as_elim]
def cases {α ε ρ : Type} {motive : ITree α ε ρ → Sort u}
    (ret : (r : ρ) → motive (.ret r))
    (tau : (x : ITree α ε ρ) → motive (.tau x))
    (vis : (e : ε) → (k : α → ITree α ε ρ) → motive (.vis e k)) :
    ∀ (x : ITree α ε ρ), motive x :=
  fun x =>
    match h : MvQPF.Cofix.dest x with
    | .ret r =>
      have h : x = ITree.ret r := by
        apply_fun MvQPF.Cofix.mk at h
        simpa [MvQPF.Cofix.mk_dest] using h
      h ▸ ret r
    | .tau y =>
      have h : x = ITree.tau y := by
        apply_fun MvQPF.Cofix.mk at h
        simpa [MvQPF.Cofix.mk_dest] using h
      h ▸ tau y
    | .vis e k =>
      have h : x = ITree.vis e k := by
        apply_fun MvQPF.Cofix.mk at h
        simpa [MvQPF.Cofix.mk_dest] using h
      h ▸ vis e k

/-- `ITree.spin` is an infinite sequence of tau-nodes. -/
def spin : ITree α ε ρ :=
  corec (fun () => .tau ()) ()

/-! ### Constructor injectivity and distinctness

These lemmas use `dest` to avoid QPF quotient elimination issues.
We use `Cofix.ext` which says two cofixed points are equal iff their `dest` are equal. -/

/-- The `dest` of a `ret` is `Base.ret`. -/
theorem dest_ret {r : ρ} : MvQPF.Cofix.dest (ITree.ret r : ITree α ε ρ) = .ret r := by
  simp only [ITree.ret, MvQPF.Cofix.dest_mk]

/-- The `dest` of a `tau` is `Base.tau`. -/
theorem dest_tau {t : ITree α ε ρ} : MvQPF.Cofix.dest (ITree.tau t) = .tau t := by
  simp only [ITree.tau, MvQPF.Cofix.dest_mk]

/-- The `dest` of a `vis` is `Base.vis`. -/
theorem dest_vis {e : ε} {k : α → ITree α ε ρ} : MvQPF.Cofix.dest (ITree.vis e k) = .vis e k := by
  simp only [ITree.vis, MvQPF.Cofix.dest_mk]

/-- `tau` is injective. -/
theorem tau_inj {t₁ t₂ : ITree α ε ρ} (h : ITree.tau t₁ = ITree.tau t₂) : t₁ = t₂ := by
  have h1 := dest_tau (t := t₁)
  have h2 := dest_tau (t := t₂)
  rw [h] at h1
  simp only [h1] at h2
  cases h2
  rfl

/-- `ret` is injective. -/
theorem ret_inj {r₁ r₂ : ρ} (h : (ITree.ret r₁ : ITree α ε ρ) = ITree.ret r₂) : r₁ = r₂ := by
  have h1 := dest_ret (r := r₁) (α := α) (ε := ε)
  have h2 := dest_ret (r := r₂) (α := α) (ε := ε)
  rw [h] at h1
  simp only [h1] at h2
  cases h2
  rfl

/-- `tau` and `ret` are distinct. -/
theorem tau_ne_ret {t : ITree α ε ρ} {r : ρ} : ITree.tau t ≠ ITree.ret r := by
  intro h
  have h1 := dest_tau (t := t)
  have h2 := dest_ret (r := r) (α := α) (ε := ε)
  rw [h] at h1
  simp only [h1] at h2
  cases h2

/-- `ret` and `tau` are distinct. -/
theorem ret_ne_tau {r : ρ} {t : ITree α ε ρ} : ITree.ret r ≠ ITree.tau t :=
  fun h => tau_ne_ret h.symm

/-- `tau` and `vis` are distinct. -/
theorem tau_ne_vis {t : ITree α ε ρ} {e : ε} {k : α → ITree α ε ρ} : ITree.tau t ≠ ITree.vis e k := by
  intro h
  have h1 := dest_tau (t := t)
  have h2 := dest_vis (e := e) (k := k)
  rw [h] at h1
  simp only [h1] at h2
  cases h2

/-- `ret` and `vis` are distinct. -/
theorem ret_ne_vis {r : ρ} {e : ε} {k : α → ITree α ε ρ} : ITree.ret r ≠ ITree.vis e k := by
  intro h
  have h1 := dest_ret (r := r) (α := α) (ε := ε)
  have h2 := dest_vis (e := e) (k := k)
  rw [h] at h1
  simp only [h1] at h2
  cases h2

/-- `vis` is injective (both in event and continuation). -/
theorem vis_inj {e₁ e₂ : ε} {k₁ k₂ : α → ITree α ε ρ}
    (h : ITree.vis e₁ k₁ = ITree.vis e₂ k₂) : e₁ = e₂ ∧ k₁ = k₂ := by
  have h1 := dest_vis (e := e₁) (k := k₁)
  have h2 := dest_vis (e := e₂) (k := k₂)
  rw [h] at h1
  simp only [h1] at h2
  cases h2
  exact ⟨rfl, rfl⟩

end ITree
